After auditing the provided source code for the `smb2_sess_setup` command and its associated functions in the `ksmbd` kernel SMB server, I have identified the following security vulnerability:

### Out-of-Bounds Read in `ntlm_negotiate`

A vulnerability exists in the `ntlm_negotiate` function (found in `smb2pdu.c`) where a crafted SMB2 Session Setup request can trigger an out-of-bounds read.

#### Technical Details
In `smb2_sess_setup`, the server extracts the security buffer (the NTLMSSP blob) from the request:

```c
// smb2pdu.c: smb2_sess_setup
negblob_off = le16_to_cpu(req->SecurityBufferOffset);
negblob_len = le16_to_cpu(req->SecurityBufferLength);
// ... validation of negblob_off ...
negblob = (struct negotiate_message *)((char *)&req->hdr.ProtocolId + negblob_off);
```

If the message type is `NtLmNegotiate`, it calls `ntlm_negotiate`:

```c
// smb2pdu.c: ntlm_negotiate
static int ntlm_negotiate(struct ksmbd_work *work,
                          struct negotiate_message *negblob,
                          size_t negblob_len, struct smb2_sess_setup_rsp *rsp)
{
    // ...
    rc = ksmbd_decode_ntlmssp_neg_blob(negblob, negblob_len, work->conn);
    // ...
    if (!work->conn->use_spnego) {
        sz = ksmbd_build_ntlmssp_challenge_blob(chgblob, work->conn);
        // ...
    }

    sz = sizeof(struct challenge_message);
    sz += (strlen(ksmbd_netbios_name()) * 2 + 1 + 4) * 6;

    neg_blob = kzalloc(sz, KSMBD_DEFAULT_GFP);
    // ...
    chgblob = (struct challenge_message *)neg_blob;
    sz = ksmbd_build_ntlmssp_challenge_blob(chgblob, work->conn);
    // ...
    rc = build_spnego_ntlmssp_neg_blob(&spnego_blob, &spnego_blob_len, neg_blob, sz);
    // ...
    memcpy(rsp->Buffer, spnego_blob, spnego_blob_len); // <--- POTENTIAL OOB READ
    rsp->SecurityBufferLength = cpu_to_le16(spnego_blob_len);
    // ...
}
```

The vulnerability lies in the `memcpy` to `rsp->Buffer`. The `rsp` pointer is derived from `work->response_buf`. The size of the response buffer is allocated earlier in the processing pipeline (typically `conn->vals->max_msgsize`), but `ntlm_negotiate` does not verify that `spnego_blob_len` fits within the remaining space of the allocated response buffer.

While `build_spnego_ntlmssp_neg_blob` (in `asn1.c`) correctly calculates the size for its own internal `buf` allocation, the resulting `spnego_blob_len` is used to copy data into `rsp->Buffer`. If an attacker provides a very large `ntlm_blob_len` (via a large NetBIOS name or other parameters influencing `sz`), `spnego_blob_len` can exceed the bounds of the `work->response_buf`.

#### Impact
An attacker can cause a kernel heap out-of-bounds read or write (depending on the state of the response buffer allocation). Since `rsp->Buffer` is part of the memory sent back to the client, this could lead to the leakage of sensitive kernel memory if the `memcpy` reads past the source or writes past the destination buffer's intended limits within the response PDU.

#### Recommendation
The `ntlm_negotiate` function should validate that `spnego_blob_len` does not exceed the available space in the response buffer. Specifically, it should check against `work->response_sz` minus the offset of the `Buffer` field in the `smb2_sess_setup_rsp` structure.

```c
unsigned int max_buffer = work->response_sz - offsetof(struct smb2_sess_setup_rsp, Buffer);
if (spnego_blob_len > max_buffer)
    return -ENOMEM;
```